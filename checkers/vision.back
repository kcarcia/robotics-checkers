// Kaitlyn Carcia
// Last Updated April 22, 2014

#include <vector>
#include <track.h>
#include <iostream>
#include <algorithm>
#include <tuple>
#include "./Grid.hpp"
#include "./points.hpp"
#include "./hsv.hpp"

using namespace std;

void sort_edges(array<iPair,3>& blob) {
 /* y has the lowest y-coordinate (top left), stick it
    at the end of the list */
 sort(blob.begin(), blob.end()
      , [](const iPair &a, const iPair &b) {
	return a.y > b.y;
      });

 /* if blob[0] has a greater X value, it's not the origin
    so swap it around */
 if(blob[0].x > blob[1].x) swap(blob[0], blob[1]);
}

iPair capture_point(int channel, int index) {
  return iPair(track_x(channel, index)
	       , track_y(channel, index));
}

/* damn.  If only we had monads. */
iPair grid_position(const iPair& pixel, float transform[2][2]) {
  int col, row;
    
  col = pixel.x * transform[0][0] + pixel.y * transform[0][1];
  row = pixel.x * transform[1][0] + pixel.y * transform[1][1];
    
  return iPair( -row , col );
}

void capture_set(vector<iPair> &vec, const iPair& origin, int channel, float transform[2][2]) {
  iPair tmp;
  for(int i = 0; (i < 10) && track_size(channel,i) > 40; ++i) {
    tmp = grid_position(capture_point(channel, i) - origin, transform) ;
    /* cout << "looking at " << tmp << " size " << track_size(channel,i) << endl; */
    if(track_size(channel,i) < 90
       && (tmp > iPair(0,0))
       && (tmp < iPair(8,8)) ) {
      vec.push_back( tmp );
    }}}

int main() {
  cout << "Begin" << endl;
  Grid g;

  int i, fail_count = 0;
  array<iPair,3> corner_marker;
  vector<iPair> human;
	
  /* aquire corner_markers */
 retry_markers:
  track_update();		
		
  /* count number of green blobs bigger than my threshold */
  i = 0;
  for(; (i < 10) && (track_size(0,i) > 200) ; ++i);

  if(i > 3) {
    if(fail_count > 10) {
      cout << "Coundn't capture orienting (green) blobs" << endl;
      cout << "  (largest " << track_size(0,0) << ")" <<endl;
      return 0;
    }
    cout << ".";
    ++fail_count;
    goto retry_markers;
  }

  for(i = 0; i < 3; ++i)
    corner_marker[i] = capture_point(0,i);

  sort_edges(corner_marker);

  /* test for skew */
  if( corner_marker[1].x >= corner_marker[2].y + 8
      &&  corner_marker[1].x <= corner_marker[2].y - 8)
    {
      cout << "(skewed; x length: " << corner_marker[1].x
	   << "y length: " << corner_marker[2].y << ")" << endl;

      goto retry_markers;
    }

  if(fail_count) cout << endl;

  cout << "have edges" << endl;
  // Calculates x and y length of individual sqare on board
  iPair edge = corner_marker[1] - corner_marker[0];
  float c, s;

  cout << "edge: " << edge << endl;

  if( edge.x > 0.01 && edge.y > 0.01 ) {
    cout << "Rotation deteced" << endl;
    c = (8.0f * corner_marker[1].x) / ((float) edge.x);
    s = (8.0f * corner_marker[1].y) / ((float) edge.y);
  } else {
    c = 8.0f / edge.x;
    s = 0;
  }

  float transform[2][2] = {{c, -s}
			   , {s, c}};

  for(int j = 0; j < 5; ++j) {
    capture_set(human, corner_marker[0], 1, transform);
    capture_set(human, corner_marker[0], 2, transform);

    // Generates the x and y coordinates of a yellow checker
    for(auto point : human)
      --g.at( point );

    human.clear();
    track_update(); 
  }

  cout << g << endl;
  return 0;
}
